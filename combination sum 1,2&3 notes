one clean notes-style framework for Combination Sum I, II, III using the same 4-step DP format (Recursion → Memoization → Tabulation → Space Optimization).

This way, you’ll have a parallel view for all three problems (great for interviews + GitHub notes).

📝 Combination Sum Problems (39, 40, 216)
🔹 Combination Sum I (LC 39)
Problem
Given distinct array candidates.

Can use each number unlimited times.

Find all unique combinations that sum to target.

1) Recursive Backtracking
Recurrence:

lua
Copy code
f(i, target) = 
   - [[]], if target == 0
   - [], if i==n or target<0
   - pick (stay at i, since reuse allowed)
   - skip (i+1)
Code:

cpp
Copy code
void solve(int i, int target, vector<int>& cand, 
           vector<int>& path, vector<vector<int>>& res) {
    if (target == 0) { res.push_back(path); return; }
    if (i >= cand.size() || target < 0) return;

    // pick (reuse allowed → stay at i)
    path.push_back(cand[i]);
    solve(i, target - cand[i], cand, path, res);
    path.pop_back();

    // skip (move to next index)
    solve(i + 1, target, cand, path, res);
}
2) Memoization (Top-Down)
Cache (i, target) results.

Stores full combinations (memory heavy).

3) Tabulation (Bottom-Up)
DP like coin change.

dp[t] = all combinations making sum t.

4) Space Optimization
Not possible if we must store all combos.

If only counting → can do O(target).

Complexity
Time: O(2^n * target/min) worst.

Space: O(target) recursion.

🔹 Combination Sum II (LC 40)
Problem
Given array candidates (may have duplicates).

Can use each number at most once.

Find all unique combinations that sum to target.

1) Recursive Backtracking
Recurrence:

lua
Copy code
f(i, target) = 
   - [[]], if target == 0
   - [], if i==n or target<0
   - pick (i+1, since no reuse)
   - skip duplicates, move forward
Code:

cpp
Copy code
void solve(int start, int target, vector<int>& cand, 
           vector<int>& path, vector<vector<int>>& res) {
    if (target == 0) { res.push_back(path); return; }

    for (int i = start; i < cand.size(); i++) {
        if (i > start && cand[i] == cand[i-1]) continue; // skip dupes
        if (cand[i] > target) break;

        path.push_back(cand[i]);
        solve(i + 1, target - cand[i], cand, path, res); // move to i+1
        path.pop_back();
    }
}
2) Memoization
Not practical (output is combinations).

For count only, memo (i,target).

3) Tabulation
Like 0/1 Knapsack DP.

Can build counts, but storing all unique combos with duplicate check is hard.

Backtracking preferred.

4) Space Optimization
Same reason → not possible when storing combos.

For counts → O(target).

Complexity
Time: O(2^n) worst case.

Space: O(n) recursion depth.

🔹 Combination Sum III (LC 216)
Problem
Use numbers from 1 to 9.

Each number at most once.

Find all unique combinations of exactly k numbers that sum to n.

1) Recursive Backtracking
Recurrence:

lua
Copy code
f(num, target, k) =
   - [[]], if target==0 && size==k
   - [], if num>9 or size>k or target<0
   - pick (num+1, target-num, k-1)
   - skip (num+1, target, k)
Code:

cpp
Copy code
void solve(int start, int k, int target, 
           vector<int>& path, vector<vector<int>>& res) {
    if (target == 0 && path.size() == k) {
        res.push_back(path);
        return;
    }
    if (target < 0 || path.size() > k) return;

    for (int num = start; num <= 9; num++) {
        path.push_back(num);
        solve(num + 1, k, target - num, path, res); // no reuse
        path.pop_back();
    }
}
2) Memoization
Possible but overkill since input is tiny (1..9).

State (start, target, size).

3) Tabulation
Can simulate knapsack with dimension (i, target, size) but not efficient.

Backtracking is best.

4) Space Optimization
Already small (<=9).

Complexity
Time: O(2^9) = 512 subsets max.

Space: O(k) recursion depth.

🎯 Final Parallel Notes Table
Problem	Input	Reuse Allowed?	Duplicates?	Extra Constraint	Best Approach
CS-I (39)	Distinct array	Yes	No	None	Backtracking (unbounded knapsack style)
CS-II (40)	Array (may have duplicates)	No	Yes (skip with sort)	None	Backtracking (0/1 knapsack style with dup-skip)
CS-III (216)	Fixed {1..9}	No	No	Exactly k numbers	Backtracking (subset sum with size constraint)

⚡ Would you like me to also add inline dry runs (like we did before) for each CS-I, II, III on one example each, so your notes have both the framework + worked example?







You said:
yes


ChatGPT said:
Perfect 🔥 — now we’ll enrich your notes with inline dry runs for each of Combination Sum I, II, III.
This way you’ll have framework + worked examples side by side (super handy for interviews and GitHub notes 🚀).

📝 Combination Sum Problems (39, 40, 216) — Full Notes with Dry Runs
🔹 Combination Sum I (LC 39)
Problem
Input: candidates = [2,3,6,7], target = 7

Unlimited reuse allowed.

Recursive Code with Dry Run
cpp
Copy code
void solve(int i, int target, vector<int>& cand, 
           vector<int>& path, vector<vector<int>>& res) {
    if (target == 0) { 
        res.push_back(path); // ✅ found a combination
        return;
    }
    if (i >= cand.size() || target < 0) return; // ❌ stop

    // pick cand[i] (stay at i since reuse allowed)
    path.push_back(cand[i]);
    solve(i, target - cand[i], cand, path, res);
    path.pop_back();

    // skip cand[i] (move to i+1)
    solve(i + 1, target, cand, path, res);
}
Dry Run ([2,3,6,7], target=7)
mathematica
Copy code
Start: i=0, target=7
Pick 2 → path=[2], target=5
   Pick 2 → path=[2,2], target=3
      Pick 2 → path=[2,2,2], target=1 (continue)
         Pick 2 → path=[2,2,2,2], target=-1 (stop)
      Skip 2 → i=1 → path=[2,2], target=1 → pick 3 → target=-2 (stop)
   Skip 2 → i=1 → path=[2], target=3
      Pick 3 → path=[2,3], target=0 ✅ → result [2,3,2] sorted → [2,2,3]
Skip 2 → i=1, target=7
   Pick 3 → path=[3], target=4
      Pick 3 → path=[3,3], target=1 → pick 3 → target=-2 (stop)
      Skip 3 → i=2 → path=[3], target=4 → pick 6 → target=-2 (stop)
   Skip 3 → i=2, target=7
      Pick 6 → path=[6], target=1 → fail
      Skip 6 → i=3, target=7
         Pick 7 → path=[7], target=0 ✅
Output: [[2,2,3],[7]]

🔹 Combination Sum II (LC 40)
Problem
Input: candidates = [10,1,2,7,6,1,5], target = 8

Each number at most once.

Must skip duplicates.

Recursive Code with Dry Run
cpp
Copy code
void solve(int start, int target, vector<int>& cand, 
           vector<int>& path, vector<vector<int>>& res) {
    if (target == 0) { res.push_back(path); return; }

    for (int i = start; i < cand.size(); i++) {
        if (i > start && cand[i] == cand[i-1]) continue; // skip dupes
        if (cand[i] > target) break;

        path.push_back(cand[i]);
        solve(i + 1, target - cand[i], cand, path, res);
        path.pop_back();
    }
}
Dry Run (sorted input = [1,1,2,5,6,7,10], target=8)
pgsql
Copy code
Start: i=0 → pick 1 → path=[1], target=7
   i=1 → skip second 1 (duplicate)
   i=2 → pick 2 → path=[1,2], target=5
       i=3 → pick 5 → path=[1,2,5], target=0 ✅
       i=4 → pick 6 → overshoot
   i=4 → pick 6 → path=[1,6], target=1 → fail
   i=5 → pick 7 → path=[1,7], target=0 ✅
i=1 → skip (dupe)
i=2 → pick 2 → path=[2], target=6
   i=4 → pick 6 → path=[2,6], target=0 ✅
i=3 → pick 5 → path=[5], target=3 → fail
i=4 → pick 6 → path=[6], target=2 → fail
i=5 → pick 7 → path=[7], target=1 → fail
Output: [[1,1,6],[1,2,5],[1,7],[2,6]]

🔹 Combination Sum III (LC 216)
Problem
Input: k=3, n=7

Use numbers 1..9, at most once.

Must use exactly k numbers.

Recursive Code with Dry Run
cpp
Copy code
void solve(int start, int k, int target, 
           vector<int>& path, vector<vector<int>>& res) {
    if (target == 0 && path.size() == k) {
        res.push_back(path); return;
    }
    if (target < 0 || path.size() > k) return;

    for (int num = start; num <= 9; num++) {
        path.push_back(num);
        solve(num + 1, k, target - num, path, res);
        path.pop_back();
    }
}
Dry Run (k=3, n=7)
lua
Copy code
Start: num=1 → path=[1], target=6
   num=2 → path=[1,2], target=4
       num=3 → path=[1,2,3], target=1 (not 0, but size=3 → fail)
       num=4 → path=[1,2,4], target=0 ✅
   num=3 → path=[1,3], target=3
       num=4 → path=[1,3,4], target=-1 → fail
   num=4 → path=[1,4], target=2
       num=5 → path=[1,4,5], target=-3 → fail
   ...
num=2 → path=[2], target=5
   num=3 → path=[2,3], target=2
       num=4 → path=[2,3,4], target=-2 → fail
   num=5 → path=[2,5], target=0 ✅
...
Output: [[1,2,4],[2,5]]

🎯 Final Comparison Table
Problem	Input	Reuse Allowed?	Duplicates?	Extra Constraint	Sample Output
CS-I (39)	Array (distinct)	Yes	No	None	[[2,2,3],[7]]
CS-II (40)	Array (dupes)	No	Yes (skip)	None	[[1,1,6],[1,2,5],[1,7],[2,6]]
CS-III (216)	{1..9}	No	No	Exactly k numbers	[[1,2,4],[2,5]]
